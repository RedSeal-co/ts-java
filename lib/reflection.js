// tsJavaModule.ts
// This file was generated by ts-java.
/// <reference path="../typings/java/java.d.ts" />
require('source-map-support').install();
var _java = require('java');
var BluePromise = require('bluebird');
var path = require('path');
_java.asyncOptions = {
    syncSuffix: '',
    asyncSuffix: 'A',
    promiseSuffix: 'P',
    promisify: BluePromise.promisify
};
// JVM initialization callback which adds tsjava.classpath to the JVM classpath.
function beforeJvm() {
    var moduleJars = ['target/reflection-1.0.0.jar'];
    moduleJars.forEach(function (jarPath) {
        _java.classpath.push(path.join(__dirname, '', jarPath));
    });
    return BluePromise.resolve();
}
_java.registerClientP(beforeJvm);
var Java;
(function (Java) {
    'use strict';
    function getJava() {
        return _java;
    }
    Java.getJava = getJava;
    function ensureJvm() {
        return _java.ensureJvm();
    }
    Java.ensureJvm = ensureJvm;
    function getClassLoader() {
        return _java.getClassLoader();
    }
    Java.getClassLoader = getClassLoader;
    // Return the fully qualified class path for a class name.
    // Returns undefined if the className is ambiguous or not present in the configured classes.
    function fullyQualifiedName(className) {
        var shortToLongMap = {
            'Boolean': 'java.lang.Boolean',
            'Class': 'java.lang.Class',
            'ClassLoader': 'java.lang.ClassLoader',
            'Integer': 'java.lang.Integer',
            'Object': 'java.lang.Object',
            'AccessibleObject': 'java.lang.reflect.AccessibleObject',
            'Constructor': 'java.lang.reflect.Constructor',
            'Executable': 'java.lang.reflect.Executable',
            'Field': 'java.lang.reflect.Field',
            'Method': 'java.lang.reflect.Method',
            'Modifier': 'java.lang.reflect.Modifier',
            'Parameter': 'java.lang.reflect.Parameter',
            'Type': 'java.lang.reflect.Type',
            'String': 'java.lang.String'
        };
        return shortToLongMap[className];
    }
    Java.fullyQualifiedName = fullyQualifiedName;
    function importClass(className) {
        var fullName = fullyQualifiedName(className) || className;
        return _java.import(fullName);
    }
    Java.importClass = importClass;
    // Returns true if javaObject is an instance of the named class, which may be a short className.
    // Returns false if javaObject is not an instance of the named class.
    // Throws an exception if the named class does not exist, or is an ambiguous short name.
    function instanceOf(javaObject, className) {
        var fullName = fullyQualifiedName(className) || className;
        return _java.instanceOf(javaObject, fullName);
    }
    Java.instanceOf = instanceOf;
    function newInstanceA(className) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        args.unshift(className);
        return _java.newInstance.apply(_java, args);
    }
    Java.newInstanceA = newInstanceA;
    function newInstance(className) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        args.unshift(className);
        return _java.newInstanceSync.apply(_java, args);
    }
    Java.newInstance = newInstance;
    function newInstanceP(className) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        args.unshift(className);
        return _java.newInstanceP.apply(_java, args);
    }
    Java.newInstanceP = newInstanceP;
    function newArray(className, arg) {
        return _java.newArray(className, arg);
    }
    Java.newArray = newArray;
})(Java = exports.Java || (exports.Java = {})); // module Module
//# sourceMappingURL=reflection.js.map