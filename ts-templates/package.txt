declare module 'java' {
  var Java: Java.Singleton;
  export = Java;
}

declare module Java {
  // Node-java has special handling for methods that return long or java.lang.Long,
  // returning a Javascript Number but with an additional property longValue.
  interface longValue_t extends Number {
    longValue: string;
  }

  // Node-java can automatically coerce a javascript string into a java.lang.String.
  // This special type alias allows to declare that possiblity to Typescript.
  export type string_t = string | java.lang.String;

  // Java methods that take java.lang.Object parameters implicitly will take a java.lang.String.
  // But string_t is not sufficient for this case, we need object_t.
  export type object_t = java.lang.Object | string | number | longValue_t;

  // Java methods that take long or java.lang.Long parameters may take javascript numbers,
  // longValue_t (see above) or java.lang.Long.
  // This special type alias allows to declare that possiblity to Typescript.
  export type long_t = number | longValue_t {{#hasClass 'java.lang.Long'}}| java.lang.Long{{/hasClass}};

  // Handling of other primitive numeric types is simpler, as there is no loss of precision.
  export type boolean_t = boolean {{#hasClass 'java.lang.Boolean'}}| java.lang.Boolean{{/hasClass}};
  export type short_t = number {{#hasClass 'java.lang.Short'}}| java.lang.Short{{/hasClass}};
  export type integer_t = number {{#hasClass 'java.lang.Integer'}}| java.lang.Integer{{/hasClass}};
  export type double_t = number {{#hasClass 'java.lang.Double'}}| java.lang.Double{{/hasClass}};
  export type float_t = number {{#hasClass 'java.lang.Float'}}| java.lang.Float{{/hasClass}};
  export type number_t = number {{#hasClass 'java.lang.Number'}}| java.lang.Number{{/hasClass}};

  export interface array_t<T> extends java.lang.Object {
    // This is an opaque type for a java array_t T[];
    // Use Java.newArray<T>(className, [...]) to create wherever a Java method expects a T[],
    // most notably for vararg parameteters.
    __dummy: T;
  }

  interface Callback<T> {
    (err: Error, result: T): void;
  }

  interface AsyncOptions {
    promiseSuffix: string;
    promisify: Function;
  }

  // *Singleton* declares methods & members exported by the node java module.
  interface Singleton {
    classpath: string[];
    asyncOptions: AsyncOptions;
    callMethod(instance: any, className: string, methodName: string, args: any[], callback: Callback<any>): void;
    callMethodSync(instance: any, className: string, methodName: string, ...args: any[]): any;
    callStaticMethodSync(className: string, methodName: string, ...args: any[]): any;
    instanceOf(javaObject: any, className: string): boolean;

    {{#hasClass 'java.lang.Short'}}newShort(val: number): java.lang.Short;
    {{/hasClass}}
    {{#hasClass 'java.lang.Long'}}newLong(val: number): java.lang.Long;
    {{/hasClass}}
    {{#hasClass 'java.lang.Float'}}newFloat(val: number): java.lang.Float;
    {{/hasClass}}
    {{#hasClass 'java.lang.Double'}}newDouble(val: number): java.lang.Double;
    {{/hasClass}}

    {{#hasClass 'java.lang.ClassLoader'}}getClassLoader(): java.lang.ClassLoader;
    {{/hasClass}}

    {{#each this}}
    newArray(className: '{{packageName}}.{{shortName}}', arg: {{tsType}}[]): array_t<{{packageName}}.{{shortName}}>;
    {{/each}}
    newArray<T>(className: string, arg: any[]): array_t<T>;

    {{#each this}}
    import(className: '{{packageName}}.{{shortName}}'): {{packageName}}.{{shortName}}.Static;
    {{/each}}
    import(className: string): any;

    {{#each this}}
    {{#each constructors}}
    newInstance(className: '{{../packageName}}.{{../shortName}}'{{#if tsParamTypes}}, {{{margs this}}}{{/if}}, cb: Callback<{{{tsReturns}}}>): void;
    {{/each}}
    {{/each}}
    newInstance(className: string, ...args: any[]): void;

    {{#each this}}
    {{#each constructors}}
    newInstanceSync(className: '{{../packageName}}.{{../shortName}}'{{#if tsParamTypes}}, {{{margs this}}}{{/if}}): {{{tsReturns}}};
    {{/each}}
    {{/each}}
    newInstanceSync(className: string, ...args: any[]): any;

    {{#each this}}
    {{#each constructors}}
    newInstancePromise(className: '{{../packageName}}.{{../shortName}}'{{#if tsParamTypes}}, {{{margs this}}}{{/if}}): Promise<{{{tsReturns}}}>;
    {{/each}}
    {{/each}}
    newInstancePromise(className: string, ...args: any[]): Promise<any>;
  }

  {{#each this}}
  {{#if useAlias}}
  export import {{alias}} = {{packageName}}.{{shortName}};
  {{/if}}
  {{/each}}

  {{#each this}}
  export module {{packageName}} {
    export interface {{shortName}} {{#if tsInterfaces}}extends {{tsInterfaces}}{{/if}} {
      {{#each variants}}
      // {{@key}}
      {{#each this}}
      // {{{generic_proto}}}
      {{#if isStatic}}
      // static method, see {{shortName}}.Static
      {{else}}
      {{name}}({{#if tsParamTypes}}{{{margs this}}},{{/if}} cb: Callback<{{{tsReturns}}}>): void;
      {{name}}Sync({{{margs this}}}): {{{tsReturns}}};
      {{name}}Promise({{{margs this}}}): Promise<{{{tsReturns}}}>;
      {{/if}}
      {{/each}}
      {{/each}}
    }
    export module {{shortName}} {
      export interface Static {
        {{#each constructors}}
        new ({{{margs this}}}): {{../packageName}}.{{../shortName}};
        {{/each}}
        {{#each variants}}
        {{#each this}}
        {{#if isStatic}}
        // {{{generic_proto}}}
        {{name}}({{#if tsParamTypes}}{{{margs this}}},{{/if}} cb: Callback<{{{tsReturns}}}>): void;
        {{name}}Sync({{{margs this}}}): {{{tsReturns}}};
        {{name}}Promise({{{margs this}}}): Promise<{{{tsReturns}}}>;
        {{/if}}
        {{/each}}
        {{/each}}
        {{#each enumConstants}}
        {{this}}: {{../shortName}};
        {{/each}}
      }
    }
  }

  {{/each}}
}
