// java.d.ts
// This file was generated by ts-java.
/// <reference path='../typings/bluebird/bluebird.d.ts' />

interface Callback<T> {
  (err: Error, result: T): void;
}

declare module 'java' {
  import Promise = require('bluebird');

  interface AsyncOptions {
    promiseSuffix: string;
    promisify: Function;
  }

  // *Singleton* declares methods & members exported by the node java module.
  interface Singleton {
    classpath: string[];
    asyncOptions: AsyncOptions;
    callMethodSync(instance: any, className: string, methodName: string, ...args: any[]): any;
    callStaticMethodSync(className: string, methodName: string, ...args: any[]): any;

    newArray<T>(className: string, arg: any[]): Java.Array<T>;

    {{#each this}}
    import(className: '{{packageName}}.{{shortName}}'): Java.{{packageName}}.{{shortName}}.Static;
    {{/each}}
    import(className: string): any;

    // TODO: use constructor signature for each class instead of ...args: any[]
    // TODO: Add the specialized version for each class, can only be done with constructor signatures.
    newInstance(className: string, ...args: any[]): void;

    // TODO: use constructor signature for each class instead of ...args: any[]
    {{#each this}}
    newInstanceSync(className: '{{packageName}}.{{shortName}}', ...args: any[]): Java.{{packageName}}.{{shortName}};
    {{/each}}
    newInstanceSync(className: string, ...args: any[]): any;

    // TODO: use constructor signature for each class instead of ...args: any[]
    {{#each this}}
    newInstancePromise(className: '{{packageName}}.{{shortName}}', ...args: any[]): Promise<Java.{{packageName}}.{{shortName}}>;
    {{/each}}
    newInstancePromise(className: string, ...args: any[]): any;
  }

  var Java: Singleton;
  export = Java;
}

declare module Java {
  // Node-java can automatically coerce a javascript string into a java.lang.String.
  // This special type alias allows to declare that possiblity to Typescript.
  export type string_t = string | java.lang.String;

  // Java methods that take java.lang.Object parameters implicitly will take a java.lang.String.
  // But string_t is not sufficient for this case, we need object_t.
  export type object_t = string | java.lang.Object;

  export interface Array<T> extends java.lang.Object {
    // This is an opaque type for a java array T[];
    // Use Java.newArray<T>(className, [...]) to create wherever a Java method expects a T[],
    // most notably for vararg parameteters.
    __dummy: T;
  }

  {{#each this}}
  export import {{shortName}} = {{packageName}}.{{shortName}};
  {{/each}}

  {{#each this}}
  export module {{packageName}} {
    export interface {{shortName}} {{#if tsInterfaces}}extends {{tsInterfaces}}{{/if}} {
      {{#each variants}}
      // {{@key}}
      {{#each this}}
      // {{{generic_proto}}}
      {{#if isStatic}}
      // static method, see {{shortName}}.Static
      {{else}}
      {{name}}({{#if tsParamTypes}}{{{margs this}}},{{/if}} cb: Callback<{{tsReturns}}>): void;
      {{name}}Sync({{{margs this}}}): {{tsReturns}};
      {{name}}Promise({{{margs this}}}): Promise<{{tsReturns}}>;
      {{/if}}
      {{/each}}
      {{/each}}
    }
    export module {{shortName}} {
      export interface Static {
        // TODO: add `new` signature for classes with public constructors
        // new (arg0: Type0, ...);
        {{#each variants}}
        {{#each this}}
        {{#if isStatic}}
        // {{{generic_proto}}}
        {{name}}({{#if tsParamTypes}}{{{margs this}}},{{/if}} cb: Callback<{{tsReturns}}>): void;
        {{name}}Sync({{{margs this}}}): {{tsReturns}};
        {{name}}Promise({{{margs this}}}): Promise<{{tsReturns}}>;
        {{/if}}
        {{/each}}
        {{/each}}
      }
    }
  }

  {{/each}}
}
